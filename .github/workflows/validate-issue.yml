name: Validate Plugin Issue

on:
  issues:
    types: [opened, edited, labeled]
  issue_comment:
    types: [created]

jobs:
  validate:
    # è§¦å‘æ¡ä»¶ï¼š
    # 1. Issue åˆ›å»ºä¸”æ ‡é¢˜ä»¥ [Plugin] å¼€å¤´ï¼ˆæ¨¡æ¿è‡ªåŠ¨æ·»åŠ ï¼‰
    # 2. Issue ç¼–è¾‘/æ·»åŠ æ ‡ç­¾ä¸”æœ‰ plugin-submission æ ‡ç­¾
    # 3. è¯„è®ºåŒ…å« /recheck å‘½ä»¤ä¸”æœ‰ plugin-submission æ ‡ç­¾
    if: |
      (github.event_name == 'issues' && github.event.action == 'opened' && startsWith(github.event.issue.title, '[Plugin]')) ||
      (github.event_name == 'issues' && github.event.action != 'opened' && contains(github.event.issue.labels.*.name, 'plugin-submission')) ||
      (github.event_name == 'issue_comment' && 
       contains(github.event.issue.labels.*.name, 'plugin-submission') &&
       contains(github.event.comment.body, '/recheck'))
    runs-on: ubuntu-latest
    permissions:
      issues: write
    
    steps:
      - name: Check recheck permission
        if: github.event_name == 'issue_comment'
        id: check-recheck-permission
        uses: actions/github-script@v7
        with:
          script: |
            const commenter = context.payload.comment.user.login;
            const issueAuthor = context.payload.issue.user.login;
            
            // Issue ä½œè€…å¯ä»¥ /recheck
            if (commenter === issueAuthor) {
              console.log(`âœ… @${commenter} æ˜¯ Issue ä½œè€…ï¼Œå…è®¸é‡æ–°éªŒè¯`);
              return;
            }
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯ç»´æŠ¤è€… (admin/write)
            try {
              const { data: permission } = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: commenter
              });
              
              const allowedPermissions = ['admin', 'write'];
              if (allowedPermissions.includes(permission.permission)) {
                console.log(`âœ… @${commenter} æ˜¯ç»´æŠ¤è€… (${permission.permission})ï¼Œå…è®¸é‡æ–°éªŒè¯`);
                return;
              }
            } catch (e) {
              // ä¸æ˜¯åä½œè€…
            }
            
            // æ— æƒé™ï¼Œæ·»åŠ è¯„è®ºå¹¶é€€å‡º
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `âš ï¸ @${commenter} åªæœ‰ **Issue ä½œè€…** æˆ– **ä»“åº“ç»´æŠ¤è€…** å¯ä»¥ä½¿ç”¨ \`/recheck\` å‘½ä»¤ã€‚`
            });
            
            core.setFailed(`ç”¨æˆ· @${commenter} æ²¡æœ‰æƒé™ä½¿ç”¨ /recheck`);

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Parse and Validate Plugin
        id: validate
        uses: actions/github-script@v7
        with:
          script: |
            const https = require('https');
            const fs = require('fs');
            
            // ========== è§£æ Issue å†…å®¹ ==========
            const body = context.payload.issue.body;
            console.log('Issue body:', body);
            
            const pluginIdMatch = body.match(/### æ’ä»¶ ID \/ Plugin ID\s*\n\s*\n(.+)/);
            const repoUrlMatch = body.match(/### ä»“åº“åœ°å€ \/ Repository URL\s*\n\s*\n(.+)/);
            
            if (!pluginIdMatch || !repoUrlMatch) {
              core.setOutput('status', 'error');
              core.setOutput('message', 'æ— æ³•è§£æ Issue å†…å®¹ï¼Œè¯·ä½¿ç”¨ Issue æ¨¡æ¿æäº¤ã€‚\n\nè¯·ç¡®ä¿å¡«å†™äº†ã€Œæ’ä»¶ IDã€å’Œã€Œä»“åº“åœ°å€ã€å­—æ®µã€‚');
              return;
            }
            
            const pluginId = pluginIdMatch[1].trim();
            const repoUrl = repoUrlMatch[1].trim();
            
            console.log(`Plugin ID: ${pluginId}`);
            console.log(`Repository URL: ${repoUrl}`);
            
            // ä¿å­˜è§£æç»“æœä¾›åç»­ä½¿ç”¨
            core.setOutput('plugin_id', pluginId);
            core.setOutput('repo_url', repoUrl);
            
            // ========== éªŒè¯ URL æ ¼å¼ ==========
            const urlPattern = /^https:\/\/github\.com\/[\w-]+\/[\w.-]+$/;
            if (!urlPattern.test(repoUrl)) {
              core.setOutput('status', 'error');
              core.setOutput('message', `**æ— æ•ˆçš„ä»“åº“ URL æ ¼å¼**\n\næä¾›çš„ URL: \`${repoUrl}\`\n\nè¦æ±‚æ ¼å¼: \`https://github.com/username/repo-name\`\n\nâŒ ä¸è¦åŒ…å« \`.git\` åç¼€\nâŒ ä¸è¦ä½¿ç”¨ SSH åœ°å€`);
              return;
            }
            
            // ========== éªŒè¯æ’ä»¶ ID æ ¼å¼ ==========
            const idPattern = /^[\w.-]+$/;
            if (!idPattern.test(pluginId)) {
              core.setOutput('status', 'error');
              core.setOutput('message', `**æ— æ•ˆçš„æ’ä»¶ ID æ ¼å¼**\n\næä¾›çš„ ID: \`${pluginId}\`\n\nåªå…è®¸ï¼šå­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿ \`_\`ã€ç‚¹ \`.\` å’Œè¿å­—ç¬¦ \`-\``);
              return;
            }
            
            // ========== æ£€æŸ¥é‡å¤ ==========
            const plugins = JSON.parse(fs.readFileSync('plugins.json', 'utf8'));
            
            const duplicateId = plugins.find(p => p.id === pluginId);
            if (duplicateId) {
              core.setOutput('status', 'error');
              core.setOutput('message', `**æ’ä»¶ ID å·²å­˜åœ¨**\n\n\`${pluginId}\` å·²è¢«æ³¨å†Œã€‚\n\nè¯·ä½¿ç”¨ä¸åŒçš„ IDï¼Œå»ºè®®æ ¼å¼ï¼š\`æ‚¨çš„ç”¨æˆ·å.æ’ä»¶å\``);
              return;
            }
            
            const duplicateUrl = plugins.find(p => p.repositoryUrl === repoUrl);
            if (duplicateUrl) {
              core.setOutput('status', 'error');
              core.setOutput('message', `**ä»“åº“ URL å·²å­˜åœ¨**\n\n${repoUrl}\n\nè¯¥ä»“åº“å·²è¢«æ³¨å†Œä¸ºæ’ä»¶ \`${duplicateUrl.id}\``);
              return;
            }
            
            // ========== è·å– Manifest ==========
            const branches = ['main', 'master', 'dev', 'develop'];
            let manifest = null;
            let successBranch = null;
            const fetchErrors = [];
            
            async function fetchFromBranch(branch) {
              const rawUrl = repoUrl.replace('github.com', 'raw.githubusercontent.com') + `/refs/heads/${branch}/_manifest.json`;
              console.log(`å°è¯•ä» ${branch} åˆ†æ”¯è·å–: ${rawUrl}`);
              
              return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                  reject(new Error('è¯·æ±‚è¶…æ—¶ (10ç§’)'));
                }, 10000);
                
                const req = https.get(rawUrl, res => {
                  clearTimeout(timeout);
                  
                  if (res.statusCode !== 200) {
                    reject(new Error(`HTTP ${res.statusCode}`));
                    return;
                  }
                  
                  let data = '';
                  res.on('data', chunk => data += chunk);
                  res.on('end', () => {
                    try {
                      resolve(JSON.parse(data));
                    } catch (e) {
                      reject(new Error('JSON è§£æå¤±è´¥ - è¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼'));
                    }
                  });
                });
                
                req.on('error', err => {
                  clearTimeout(timeout);
                  reject(new Error(`ç½‘ç»œé”™è¯¯: ${err.message}`));
                });
              });
            }
            
            for (const branch of branches) {
              try {
                manifest = await fetchFromBranch(branch);
                successBranch = branch;
                console.log(`âœ… æˆåŠŸä» ${branch} åˆ†æ”¯è·å–åˆ°æ¸…å•æ–‡ä»¶`);
                break;
              } catch (e) {
                fetchErrors.push(`- \`${branch}\`: ${e.message}`);
                console.log(`âŒ ${branch} åˆ†æ”¯è·å–å¤±è´¥: ${e.message}`);
              }
            }
            
            if (!manifest) {
              core.setOutput('status', 'error');
              core.setOutput('message', `**æ— æ³•è·å– \`_manifest.json\` æ–‡ä»¶**\n\nå°è¯•çš„åˆ†æ”¯:\n${fetchErrors.join('\n')}\n\n**è¯·æ£€æŸ¥:**\n1. æ–‡ä»¶åæ˜¯å¦ä¸º \`_manifest.json\`ï¼ˆæ³¨æ„ä¸‹åˆ’çº¿ï¼‰\n2. ä»“åº“æ˜¯å¦ä¸º**å…¬å¼€**ä»“åº“\n3. æ–‡ä»¶æ˜¯å¦åœ¨ä¸Šè¿°åˆ†æ”¯çš„æ ¹ç›®å½•ä¸­`);
              return;
            }
            
            // ========== éªŒè¯ Manifest ç»“æ„ ==========
            const warnings = [];
            
            // æ£€æŸ¥ç©ºæˆ–æ— æ•ˆ
            if (!manifest || typeof manifest !== 'object') {
              core.setOutput('status', 'error');
              core.setOutput('message', '`_manifest.json` æ–‡ä»¶ä¸ºç©ºæˆ–æ ¼å¼æ— æ•ˆ');
              return;
            }
            
            // æ£€æŸ¥å¿…éœ€å­—æ®µ
            const requiredFields = ['manifest_version', 'name', 'version', 'description', 'author', 'license', 'host_application'];
            const missingFields = requiredFields.filter(f => !manifest[f]);
            
            if (missingFields.length > 0) {
              core.setOutput('status', 'error');
              core.setOutput('message', `**\`_manifest.json\` ç¼ºå°‘å¿…éœ€å­—æ®µ**\n\nç¼ºå°‘: ${missingFields.map(f => '\`' + f + '\`').join(', ')}\n\nè¯·å‚è€ƒ [Manifest æ–‡æ¡£](https://docs.mai-mai.org/develop/plugin_develop/manifest-guide.html) æ·»åŠ è¿™äº›å­—æ®µã€‚`);
              return;
            }
            
            // éªŒè¯ author ç»“æ„
            if (typeof manifest.author !== 'object' || !manifest.author.name || !manifest.author.url) {
              core.setOutput('status', 'error');
              core.setOutput('message', '**\`author\` å­—æ®µæ ¼å¼é”™è¯¯**\n\nå¿…é¡»æ˜¯åŒ…å« `name` å’Œ `url` çš„å¯¹è±¡:\n```json\n"author": {\n  "name": "ä½œè€…å",\n  "url": "https://github.com/username"\n}\n```');
              return;
            }
            
            // éªŒè¯ host_application ç»“æ„
            if (typeof manifest.host_application !== 'object' || !manifest.host_application.min_version) {
              core.setOutput('status', 'error');
              core.setOutput('message', '**\`host_application\` å­—æ®µæ ¼å¼é”™è¯¯**\n\nå¿…é¡»åŒ…å« `min_version` å±æ€§:\n```json\n"host_application": {\n  "min_version": "1.0.0"\n}\n```');
              return;
            }
            
            // ========== è­¦å‘Šæ£€æŸ¥ï¼ˆä¸é˜»æ­¢æäº¤ï¼‰==========
            
            // ç‰ˆæœ¬å·æ ¼å¼
            const versionRegex = /^\d+\.\d+\.\d+/;
            if (!versionRegex.test(manifest.version)) {
              warnings.push(`ç‰ˆæœ¬å· \`${manifest.version}\` ä¸ç¬¦åˆè¯­ä¹‰åŒ–ç‰ˆæœ¬æ ¼å¼ (å¦‚ \`1.0.0\`)`);
            }
            
            // ID ä¸ manifest name ä¸ä¸€è‡´
            if (pluginId !== manifest.name) {
              warnings.push(`æ’ä»¶ ID \`${pluginId}\` ä¸ manifest ä¸­çš„ name \`${manifest.name}\` ä¸ä¸€è‡´ï¼Œå»ºè®®ä¿æŒä¸€è‡´`);
            }
            
            // ========== éªŒè¯æˆåŠŸ ==========
            let successMessage = `**æ’ä»¶ä¿¡æ¯:**\n| å­—æ®µ | å€¼ |\n|------|----|\n| åç§° | ${manifest.name} |\n| ç‰ˆæœ¬ | ${manifest.version} |\n| ä½œè€… | ${manifest.author.name} |\n| è®¸å¯è¯ | ${manifest.license} |\n| æè¿° | ${manifest.description} |\n| åˆ†æ”¯ | ${successBranch} |`;
            
            if (warnings.length > 0) {
              successMessage += `\n\n**âš ï¸ è­¦å‘Š (ä¸å½±å“æäº¤):**\n${warnings.map(w => '- ' + w).join('\n')}`;
            }
            
            successMessage += `\n\n---\n\n**ç»´æŠ¤è€…æ“ä½œ:**\n- \`/approve\` - æ‰¹å‡†å¹¶æ·»åŠ æ­¤æ’ä»¶\n- \`/reject åŸå› \` - æ‹’ç»æ­¤æ’ä»¶\n\n**æäº¤è€…æ“ä½œ:**\n- å¦‚æœä¿®æ”¹äº† manifestï¼Œå¯ä»¥è¯„è®º \`/recheck\` é‡æ–°éªŒè¯`;
            
            core.setOutput('status', 'success');
            core.setOutput('message', successMessage);
            core.setOutput('manifest_name', manifest.name);
            core.setOutput('manifest_version', manifest.version);
            core.setOutput('manifest_author', manifest.author.name);
            core.setOutput('manifest_license', manifest.license);

      - name: Remove old status labels
        uses: actions/github-script@v7
        with:
          script: |
            const labels = context.payload.issue.labels.map(l => l.name);
            const statusLabels = ['validated', 'validation-failed', 'pending-validation'];
            
            for (const label of statusLabels) {
              if (labels.includes(label)) {
                try {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    name: label
                  });
                } catch (e) {
                  // Label might not exist, ignore
                }
              }
            }

      - name: Add status label and comment
        uses: actions/github-script@v7
        with:
          script: |
            const status = '${{ steps.validate.outputs.status }}';
            const message = String.raw`${{ steps.validate.outputs.message }}`;
            const isRecheck = '${{ github.event_name }}' === 'issue_comment';
            
            // ç¡®å®šæ ‡ç­¾
            const label = status === 'success' ? 'validated' : 'validation-failed';
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: [label]
            });
            
            // æ„å»ºè¯„è®º
            const emoji = status === 'success' ? 'âœ…' : 'âŒ';
            const title = status === 'success' ? 'éªŒè¯é€šè¿‡ / Validation Passed' : 'éªŒè¯å¤±è´¥ / Validation Failed';
            const recheckNote = isRecheck ? '\n\n> ğŸ”„ æ­¤ä¸ºé‡æ–°éªŒè¯ç»“æœ' : '';
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `## ${emoji} ${title}${recheckNote}\n\n${message}`
            });
