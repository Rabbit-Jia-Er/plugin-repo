name: Validate Plugin PR (Deprecated)

on:
  pull_request_target:
    branches:
      - main
    paths:
      - 'plugins.json'

jobs:
  guide-to-issue:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
    steps:
      - name: Guide user to Issue submission
        uses: actions/github-script@v7
        with:
          script: |
            const prAuthor = context.payload.pull_request.user.login;
            
            const message = `## ğŸ“¢ æ¨èä½¿ç”¨ Issue æäº¤æ’ä»¶ / Please Use Issue Submission
            
            @${prAuthor} æ‚¨å¥½ï¼
            
            æˆ‘ä»¬å·²ç»æ¨å‡ºäº†æ›´ç®€å•çš„ **Issue æäº¤æ–¹å¼**ï¼Œæ— éœ€ Fork å’Œåˆ›å»º PRã€‚
            
            ### ğŸš€ æ¨èæµç¨‹
            
            1. å…³é—­æ­¤ PR
            2. ç‚¹å‡» [åˆ›å»º Issue](https://github.com/${context.repo.owner}/${context.repo.repo}/issues/new/choose)
            3. é€‰æ‹© **"Add Plugin / æ·»åŠ æ’ä»¶"** æ¨¡æ¿
            4. å¡«å†™æ’ä»¶ ID å’Œä»“åº“åœ°å€
            5. CI è‡ªåŠ¨éªŒè¯ï¼Œç»´æŠ¤è€…æ‰¹å‡†åè‡ªåŠ¨æ·»åŠ 
            
            ### âœ¨ Issue æ–¹å¼çš„ä¼˜åŠ¿
            
            | ç‰¹æ€§ | PR æ–¹å¼ | Issue æ–¹å¼ |
            |------|---------|------------|
            | éœ€è¦ Fork | âœ… éœ€è¦ | âŒ ä¸éœ€è¦ |
            | éœ€è¦æœ¬åœ° Git | âœ… éœ€è¦ | âŒ ä¸éœ€è¦ |
            | åˆå¹¶å†²çª | å¯èƒ½å‘ç”Ÿ | ä¸ä¼šå‘ç”Ÿ |
            | æ“ä½œå¤æ‚åº¦ | è¾ƒé«˜ | éå¸¸ç®€å• |
            
            ---
            
            > âš ï¸ **PR æäº¤æ–¹å¼å·²å¼ƒç”¨**ï¼Œåç»­å¯èƒ½ä¼šç§»é™¤æ”¯æŒã€‚
            > 
            > å¦‚æœæ‚¨ä»å¸Œæœ›ä½¿ç”¨ PR æ–¹å¼ï¼Œæ­¤ PR ä»ä¼šè¿›è¡ŒéªŒè¯ï¼Œä½†å»ºè®®æ”¹ç”¨ Issueã€‚
            `;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: message
            });
  validate:
    runs-on: ubuntu-latest
    needs: guide-to-issue
    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          path: main

      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.pull_request.head.repo.full_name }}
          ref: ${{ github.event.pull_request.head.sha }}
          persist-credentials: false
          path: pr

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Validate new plugin entry
        run: |
          node <<'EOL'
          const fs = require('fs');
          const https = require('https');

          async function main() {
            try {
              const mainPlugins = JSON.parse(fs.readFileSync('main/plugins.json', 'utf8'));
              const prPlugins = JSON.parse(fs.readFileSync('pr/plugins.json', 'utf8'));

              console.log(`ä¸»åˆ†æ”¯æœ‰ ${mainPlugins.length} ä¸ªæ’ä»¶`);
              console.log(`PR åˆ†æ”¯æœ‰ ${prPlugins.length} ä¸ªæ’ä»¶`);

              const mainRepoUrls = new Set(mainPlugins.map(p => p.repositoryUrl));
              const mainPluginIds = new Set(mainPlugins.map(p => p.id));
              
              const newPlugins = prPlugins.filter(p => 
                !mainRepoUrls.has(p.repositoryUrl) && !mainPluginIds.has(p.id)
              );

              const modifiedPlugins = prPlugins.filter(p => {
                const mainPlugin = mainPlugins.find(mp => 
                  mp.repositoryUrl === p.repositoryUrl || mp.id === p.id
                );
                return mainPlugin && JSON.stringify(mainPlugin) !== JSON.stringify(p);
              });

              const missingPlugins = mainPlugins.filter(mp => 
                !prPlugins.some(p => p.repositoryUrl === mp.repositoryUrl || p.id === mp.id)
              );

              if (missingPlugins.length > 0) {
                console.warn(`âš ï¸  è­¦å‘Šï¼šPR åˆ†æ”¯ç¼ºå°‘ä¸»åˆ†æ”¯ä¸­å­˜åœ¨çš„ ${missingPlugins.length} ä¸ªæ’ä»¶ï¼š`);
                missingPlugins.forEach(p => console.warn(`  - ${p.id} (${p.repositoryUrl})`));
                console.warn(`è¿™è¡¨æ˜ PR åˆ†æ”¯å¯èƒ½å·²è¿‡æ—¶ã€‚å»ºè®®ä½¿ç”¨ Issue æ–¹å¼æäº¤ï¼Œé¿å…åˆå¹¶å†²çªã€‚`);
              }

              if (newPlugins.length === 0 && modifiedPlugins.length === 0) {
                console.log('åœ¨ plugins.json ä¸­æœªæ£€æµ‹åˆ°æ–°æ’ä»¶æˆ–ä¿®æ”¹çš„æ’ä»¶ã€‚');
                process.exit(0);
              }

              const prRepoUrls = prPlugins.map(p => p.repositoryUrl);
              const prPluginIds = prPlugins.map(p => p.id);
              const duplicateUrls = prRepoUrls.filter((url, index) => prRepoUrls.indexOf(url) !== index);
              const duplicateIds = prPluginIds.filter((id, index) => prPluginIds.indexOf(id) !== index);

              if (duplicateUrls.length > 0) {
                throw new Error(`åœ¨ PR ä¸­å‘ç°é‡å¤çš„ä»“åº“ URLï¼š${duplicateUrls.join(', ')}`);
              }
              if (duplicateIds.length > 0) {
                throw new Error(`åœ¨ PR ä¸­å‘ç°é‡å¤çš„æ’ä»¶ IDï¼š${duplicateIds.join(', ')}`);
              }

              if (newPlugins.length > 1) {
                throw new Error('é”™è¯¯ï¼šæ¯ä¸ª Pull Request åªèƒ½æäº¤ä¸€ä¸ªæ–°æ’ä»¶ã€‚å»ºè®®ä½¿ç”¨ Issue æ–¹å¼æäº¤ã€‚');
              }

              let validationErrors = [];
              
              for (const plugin of newPlugins) {
                try {
                  console.log(`\n=== éªŒè¯æ–°æ’ä»¶ï¼š${plugin.id} ===`);
                  console.log(`ä»“åº“åœ°å€ï¼š${plugin.repositoryUrl}`);
                  const manifest = await fetchManifest(plugin.repositoryUrl);
                  validateManifest(manifest, plugin);
                  console.log(`âœ… æ–°æ’ä»¶éªŒè¯æˆåŠŸï¼š${plugin.id}\n`);
                } catch (error) {
                  const errorMsg = `æ–°æ’ä»¶ ${plugin.id} éªŒè¯å¤±è´¥ï¼š${error.message}`;
                  console.error(`âŒ ${errorMsg}\n`);
                  validationErrors.push(errorMsg);
                }
              }

              for (const plugin of modifiedPlugins) {
                try {
                  console.log(`\n=== éªŒè¯ä¿®æ”¹çš„æ’ä»¶ï¼š${plugin.id} ===`);
                  console.log(`ä»“åº“åœ°å€ï¼š${plugin.repositoryUrl}`);
                  const manifest = await fetchManifest(plugin.repositoryUrl);
                  validateManifest(manifest, plugin);
                  console.log(`âœ… ä¿®æ”¹æ’ä»¶éªŒè¯æˆåŠŸï¼š${plugin.id}\n`);
                } catch (error) {
                  const errorMsg = `ä¿®æ”¹æ’ä»¶ ${plugin.id} éªŒè¯å¤±è´¥ï¼š${error.message}`;
                  console.error(`âŒ ${errorMsg}\n`);
                  validationErrors.push(errorMsg);
                }
              }

              if (validationErrors.length > 0) {
                console.error(`\nâŒ å‘ç° ${validationErrors.length} ä¸ªéªŒè¯é”™è¯¯ï¼š`);
                validationErrors.forEach((error, index) => {
                  console.error(`${index + 1}. ${error}`);
                });
                throw new Error(`æ’ä»¶éªŒè¯å¤±è´¥ï¼Œå…± ${validationErrors.length} ä¸ªé”™è¯¯ã€‚å»ºè®®ä½¿ç”¨ Issue æ–¹å¼æäº¤ä»¥è·å¾—æ›´å¥½çš„åé¦ˆã€‚`);
              }

              console.log(`âœ… éªŒè¯æˆåŠŸï¼å¤„ç†äº† ${newPlugins.length} ä¸ªæ–°æ’ä»¶å’Œ ${modifiedPlugins.length} ä¸ªä¿®æ”¹çš„æ’ä»¶ã€‚`);
              console.log(`\nğŸ’¡ æç¤ºï¼šå»ºè®®æ”¹ç”¨ Issue æ–¹å¼æäº¤ï¼Œæ“ä½œæ›´ç®€å•ä¸”ä¸ä¼šæœ‰åˆå¹¶å†²çªã€‚`);
            } catch (error) {
              console.error(`âŒ éªŒè¯å¤±è´¥ï¼š${error.message}`);
              process.exit(1);
            }
          }

          function fetchManifest(repoUrl) {
            const branches = ['main', 'master', 'dev', 'develop'];
            
            async function tryFetchFromBranch(branch) {
              const rawUrl = repoUrl.replace('github.com', 'raw.githubusercontent.com') + `/refs/heads/${branch}/_manifest.json`;
              console.log(`å°è¯•ä» ${branch} åˆ†æ”¯è·å–æ¸…å•æ–‡ä»¶ï¼š${rawUrl}`);
              
              return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                  reject(new Error(`è·å–æ¸…å•æ–‡ä»¶è¶…æ—¶ï¼ˆ10ç§’ï¼‰ï¼š${rawUrl}`));
                }, 10000);

                const req = https.get(rawUrl, res => {
                  clearTimeout(timeout);
                  
                  if (res.statusCode !== 200) {
                    return reject(new Error(`çŠ¶æ€ç ï¼š${res.statusCode}`));
                  }
                  
                  let data = '';
                  res.on('data', chunk => data += chunk);
                  res.on('end', () => {
                    try {
                      const manifest = JSON.parse(data);
                      resolve({ manifest, branch, url: rawUrl });
                    } catch (parseError) {
                      reject(new Error(`JSON è§£æå¤±è´¥ï¼š${parseError.message}`));
                    }
                  });
                  res.on('error', err => {
                    clearTimeout(timeout);
                    reject(new Error(`è¯»å–å“åº”æ•°æ®æ—¶å‡ºé”™ï¼š${err.message}`));
                  });
                });

                req.on('error', err => {
                  clearTimeout(timeout);
                  reject(new Error(`ç½‘ç»œé”™è¯¯ï¼š${err.message}`));
                });

                req.setTimeout(10000, () => {
                  req.destroy();
                  reject(new Error(`è¯·æ±‚è¶…æ—¶`));
                });
              });
            }

            return (async () => {
              const errors = [];
              
              for (const branch of branches) {
                try {
                  const result = await tryFetchFromBranch(branch);
                  console.log(`âœ… æˆåŠŸä» ${result.branch} åˆ†æ”¯è·å–åˆ°æ¸…å•æ–‡ä»¶`);
                  return result.manifest;
                } catch (error) {
                  errors.push(`${branch} åˆ†æ”¯: ${error.message}`);
                  console.log(`âŒ ${branch} åˆ†æ”¯è·å–å¤±è´¥: ${error.message}`);
                }
              }
              
              throw new Error(`æ— æ³•ä»ä»»ä½•åˆ†æ”¯è·å– _manifest.json æ–‡ä»¶ã€‚å°è¯•çš„åˆ†æ”¯ï¼š${branches.join(', ')}ã€‚é”™è¯¯è¯¦æƒ…ï¼š\n${errors.map((err, i) => `${i + 1}. ${err}`).join('\n')}ã€‚\n\nè¯·æ£€æŸ¥ï¼š\n1. æ–‡ä»¶åæ˜¯å¦ä¸º '_manifest.json'ï¼ˆæ³¨æ„ä¸‹åˆ’çº¿ï¼‰\n2. ä»“åº“æ˜¯å¦ä¸ºå…¬å¼€ä»“åº“\n3. æ–‡ä»¶æ˜¯å¦å­˜åœ¨äºä¸Šè¿°åˆ†æ”¯ä¸­\nä»“åº“åœ°å€ï¼š${repoUrl}`);
            })();
          }

          function validateManifest(manifest, plugin) {
            if (!manifest || typeof manifest !== 'object') {
              throw new Error('_manifest.json æ–‡ä»¶ä¸ºç©ºæˆ–æ ¼å¼æ— æ•ˆ');
            }

            const requiredFields = ['manifest_version', 'name', 'version', 'description', 'author', 'license', 'host_application'];
            for (const field of requiredFields) {
              if (!manifest[field]) throw new Error(`_manifest.json ç¼ºå°‘å¿…éœ€å­—æ®µï¼š'${field}'`);
            }
            
            if (typeof manifest.author !== 'object' || !manifest.author.name || !manifest.author.url) {
                throw new Error("_manifest.json 'author' å­—æ®µå¿…é¡»æ˜¯ä¸€ä¸ªåŒ…å« 'name' å’Œ 'url' å±æ€§çš„å¯¹è±¡ã€‚");
            }
            if (typeof manifest.host_application !== 'object' || !manifest.host_application.min_version) {
                throw new Error("_manifest.json 'host_application' å­—æ®µå¿…é¡»æ˜¯ä¸€ä¸ªåŒ…å« 'min_version' å±æ€§çš„å¯¹è±¡ã€‚");
            }

            const versionRegex = /^\d+\.\d+\.\d+/;
            if (!versionRegex.test(manifest.version)) {
              console.warn(`è­¦å‘Šï¼šæ’ä»¶ç‰ˆæœ¬ '${manifest.version}' ä¸ç¬¦åˆè¯­ä¹‰åŒ–ç‰ˆæœ¬æ ¼å¼ï¼ˆå¦‚ï¼š1.0.0ï¼‰`);
            }

            if (plugin && plugin.id !== manifest.name) {
              console.warn(`è­¦å‘Šï¼šplugins.json ä¸­çš„æ’ä»¶ ID '${plugin.id}' ä¸æ¸…å•æ–‡ä»¶ä¸­çš„åç§° '${manifest.name}' ä¸åŒã€‚å»ºè®®ä¿æŒä¸€è‡´ã€‚`);
            }

            console.log(`æ’ä»¶æ¸…å•ç»“æ„æœ‰æ•ˆï¼š${manifest.name} v${manifest.version}`);
          }

          main();
          EOL
